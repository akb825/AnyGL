#!/bin/python
#
# Copyright 2017 Aaron Barany
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import errno, io, os, re, shutil, string, sys
from optparse import OptionParser
from lxml import etree
from reg import *

class FunctionInfo:
	def __init__(self, cmd):
		self.proto = cmd.find('proto')
		self.params = cmd.findall('param')
		alias = cmd.find('alias')
		if alias == None:
			self.alias = None
		else:
			self.alias = alias.get('name')

		self.type = None
		for elem in self.proto:
			if elem.tag == 'name':
				text = noneStr(elem.text)
				tail = noneStr(elem.tail)
				self.name = noneStr(elem.text)

		if self.alias:
			self.type = 'PFN' + self.alias.upper() + 'PROC'
		else:
			self.type = 'PFN' + self.name.upper() + 'PROC'

	def getTypeDecl(self):
		typeDecl = 'typedef ' + noneStr(self.proto.text)
		for elem in self.proto:
			text = noneStr(elem.text)
			tail = noneStr(elem.tail)
			if elem.tag == 'name':
				typeDecl += '(APIENTRY* ' + self.type + ')'
			else:
				typeDecl += text + tail

		n = len(self.params)
		typeDecl += '('
		for i in range(0, n):
			typeDecl += str().join([t for t in self.params[i].itertext()])
			if i < n - 1:
				typeDecl += ', '
		typeDecl += ');'
		return typeDecl

	def getFunctionDecl(self):
		decl = 'APIENTRY ' + noneStr(self.proto.text)
		for elem in self.proto:
			text = noneStr(elem.text)
			tail = noneStr(elem.tail)
			decl += text + tail

		n = len(self.params)
		decl += '('
		for i in range(0, n):
			decl += str().join([t for t in self.params[i].itertext()])
			if i < n - 1:
				decl += ', '
		decl += ');'
		return decl

class GLHeaderGenerator(OutputGenerator):
	def __init__(self, errFile = sys.stderr, warnFile = sys.stderr, diagFile = sys.stdout):
		OutputGenerator.__init__(self, errFile, warnFile, diagFile)
		self.lastRequire = None
		self.glesOnlyTypes = ['khrplatform']
		self.glOnlyTypes = \
			[
				'stddef',
				'inttypes',
				'GLfloat',
				'GLdouble',
				'GLclampf',
				'GLclampd'
			]
		self.curFunctions = []

	def newLine(self):
		write('', file = self.outFile)

	def beginFile(self, genOpts):
		OutputGenerator.beginFile(self, genOpts)
		if self.genOpts.filename:
			headerSym = '__AnyGL_' + re.sub('\.h', '_h_', os.path.basename(self.genOpts.filename))
			write('#pragma once', file = self.outFile)
			write('#ifndef', headerSym, file = self.outFile)
			write('#define', headerSym, '1', file = self.outFile)
			self.newLine()

		write('#include "AnyGLConfig.h"', file = self.outFile)
		self.newLine()

		write('/* Generated by AnyGL. */', file = self.outFile)
		self.newLine()

		write('#ifdef __cplusplus', file= self.outFile)
		write('extern "C" {', file = self.outFile)
		write('#endif', file = self.outFile)
		self.newLine()

	def endFile(self):
		self.newLine()
		write('#ifdef __cplusplus', file = self.outFile)
		write('}', file = self.outFile)
		write('#endif', file = self.outFile)

		if self.genOpts.filename:
			self.newLine()
			write('#endif', file = self.outFile)

		OutputGenerator.endFile(self)

	def beginFeature(self, interface, emit):
		OutputGenerator.beginFeature(self, interface, emit)
		if emit:
			write('/*', interface.get('name'), '*/', file = self.outFile)

	def endFeature(self):
		if self.lastRequire:
			write('#endif /*', self.lastRequire, '*/', file = self.outFile)
			self.lastRequire = None
		self.newLine()

		if self.curFunctions:
			# Function types
			for function in self.curFunctions:
				if not function.alias:
					write(function.getTypeDecl(), file = self.outFile)
			self.newLine()

			# Function pointers
			for function in self.curFunctions:
				if not function.alias:
					write('ANYGL_EXPORT extern', function.type, 'AnyGL_' + function.name + ';',
						file = self.outFile)
			self.newLine()

			# Function defines.
			for function in self.curFunctions:
				name = function.name
				if function.alias:
					name = function.alias
				write('#define', function.name, 'AnyGL_' + name, file = self.outFile)
			self.newLine()

		self.curFunctions = []
		OutputGenerator.endFeature(self)

	def genType(self, typeinfo, name):
		OutputGenerator.genType(self, typeinfo, name)

		# Types are declared differently between GLES and desktop GL.
		typeElem = typeinfo.elem
		curRequire = None
		requires = typeElem.get('requires')
		if requires == 'khrplatform':
			curRequire = 'ANYGL_GLES'
		elif requires in self.glOnlyTypes:
			curRequire = '!ANYGL_GLES'
		else:
			name = typeElem.get('name')
			if name in self.glesOnlyTypes:
				curRequire = 'ANYGL_GLES'
			elif name in self.glOnlyTypes:
				curRequire = '!ANYGL_GLES'

		if curRequire != self.lastRequire:
			if self.lastRequire:
				write('#endif /*', self.lastRequire, '*/', file = self.outFile)

			self.newLine()
			if curRequire:
				write('#if', curRequire, file = self.outFile)
			self.lastRequire = curRequire

		s = noneStr(typeElem.text)
		for elem in typeElem:
			if (elem.tag == 'apientry'):
				s += 'APIENTRY' + noneStr(elem.tail)
			else:
				s += noneStr(elem.text) + noneStr(elem.tail)
		if (len(s) > 0):
			write(s, file = self.outFile)

	def genEnum(self, enuminfo, name):
		OutputGenerator.genEnum(self, enuminfo, name)

		# Special case: GL_HALF_FLOAT_OES is a different value from GL_HALF_FLOAT
		glOnly = name == 'GL_HALF_FLOAT'
		if glOnly:
			write('#if !ANYGL_GLES', file = self.outFile)

		s = '#define ' + name.ljust(33) + ' ' + enuminfo.elem.get('value')
		#
		# Handle non-integer 'type' fields by using it as the C value suffix
		t = enuminfo.elem.get('type')
		if (t != '' and t != 'i'):
			s += enuminfo.type
		write(s, file = self.outFile)

		# Special case for GL_HALF_FLOAT_OES
		if name == 'GL_HALF_FLOAT_OES':
			write('#define GL_HALF_FLOAT GL_HALF_FLOAT_OES', file = self.outFile)

		if glOnly:
			write('#endif /* !ANYGL_GLES */', file = self.outFile)

	def genCmd(self, cmdinfo, name):
		OutputGenerator.genCmd(self, cmdinfo, name)
		self.curFunctions.append(FunctionInfo(cmdinfo.elem))

class FunctionPointerGenerator(OutputGenerator):
	def __init__(self, errFile = sys.stderr, warnFile = sys.stderr, diagFile = sys.stdout):
		OutputGenerator.__init__(self, errFile, warnFile, diagFile)

	def newLine(self):
		write('', file = self.outFile)

	def beginFile(self, genOpts):
		OutputGenerator.beginFile(self, genOpts)
		write('#include "gl.h"', file = self.outFile)
		self.newLine()

		write('/* Generated by AnyGL. */', file = self.outFile)
		self.newLine()

	def genCmd(self, cmdinfo, name):
		OutputGenerator.genCmd(self, cmdinfo, name)
		function = FunctionInfo(cmdinfo.elem)
		if not function.alias:
			write('ANYGL_EXPORT', function.type, 'AnyGL_' + function.name + ';',
				file = self.outFile)

class GLXWHeaderGenerator(OutputGenerator):
	def __init__(self, systemIncludes, define, systemDefines = [], errFile = sys.stderr,
		warnFile = sys.stderr, diagFile = sys.stdout):
		OutputGenerator.__init__(self, errFile, warnFile, diagFile)
		self.systemIncludes = systemIncludes
		self.systemDefines = systemDefines
		self.define = define
		self.curFunctions = []
		self.extension = False

	def newLine(self):
		write('', file = self.outFile)

	def beginFile(self, genOpts):
		OutputGenerator.beginFile(self, genOpts)
		if self.genOpts.filename:
			headerSym = '__AnyGL_' + re.sub('\.h', '_h_', os.path.basename(self.genOpts.filename))
			write('#pragma once', file = self.outFile)
			write('#ifndef', headerSym, file = self.outFile)
			write('#define', headerSym, '1', file = self.outFile)
			self.newLine()

		write('#include "AnyGLConfig.h"', file = self.outFile)
		write('#include "gl.h"', file = self.outFile)
		self.newLine()
		write('#if ANYGL_LOAD ==', self.define, file = self.outFile)
		for define in self.systemDefines:
			write('#define', define, file=self.outFile)
		for include in self.systemIncludes:
			write('#include <' + include + '>', file = self.outFile)
		self.newLine()

		write('/* Generated by AnyGL. */', file = self.outFile)
		self.newLine()

		write('#ifdef __cplusplus', file= self.outFile)
		write('extern "C" {', file = self.outFile)
		write('#endif', file = self.outFile)
		self.newLine()

	def endFile(self):
		self.newLine()
		write('#ifdef __cplusplus', file = self.outFile)
		write('}', file = self.outFile)
		write('#endif', file = self.outFile)

		self.newLine()
		write('#endif /* ANYGL_LOAD */', file = self.outFile)
		self.newLine()

		if self.genOpts.filename:
			self.newLine()
			write('#endif', file = self.outFile)

		OutputGenerator.endFile(self)

	def beginFeature(self, interface, emit):
		OutputGenerator.beginFeature(self, interface, emit)
		if emit:
			write('/*', interface.get('name'), '*/', file = self.outFile)
		self.extension = interface.tag == 'extension'

	def endFeature(self):
		self.newLine()

		if self.curFunctions:
			if self.extension:
				# Function types
				for function in self.curFunctions:
					write(function.getTypeDecl(), file = self.outFile)
				self.newLine()

				# Function pointers
				for function in self.curFunctions:
					write('ANYGL_EXPORT extern', function.type, 'AnyGL_' + function.name + ';',
						file = self.outFile)
				self.newLine()

				# Function defines.
				for function in self.curFunctions:
					write('#define', function.name, 'AnyGL_' + function.name, file = self.outFile)
				self.newLine()
			else:
				for function in self.curFunctions:
					write(function.getFunctionDecl(), file = self.outFile)
				self.newLine()

		self.curFunctions = []
		OutputGenerator.endFeature(self)

	def genType(self, typeinfo, name):
		OutputGenerator.genType(self, typeinfo, name)

		typeElem = typeinfo.elem
		s = noneStr(typeElem.text)
		for elem in typeElem:
			if (elem.tag == 'apientry'):
				s += 'APIENTRY' + noneStr(elem.tail)
			else:
				s += noneStr(elem.text) + noneStr(elem.tail)
		if (len(s) > 0):
			write(s, file = self.outFile)

	def genEnum(self, enuminfo, name):
		OutputGenerator.genEnum(self, enuminfo, name)

		s = '#define ' + name.ljust(33) + ' ' + enuminfo.elem.get('value')
		#
		# Handle non-integer 'type' fields by using it as the C value suffix
		t = enuminfo.elem.get('type')
		if (t != '' and t != 'i'):
			s += enuminfo.type
		write(s, file = self.outFile)

	def genCmd(self, cmdinfo, name):
		OutputGenerator.genCmd(self, cmdinfo, name)
		self.curFunctions.append(FunctionInfo(cmdinfo.elem))

options = OptionParser()
options.add_option('-i', '--input', dest = 'inDir', help = 'Input directory with the XML files.',
	default = 'OpenGLRegistry/xml')
options.add_option('-o', '--output', dest = 'outDir',
	help = 'Output directory for the generated files.', default = 'generated')
options.add_option('-t', '--template-dir', dest='templateDir',
	help = 'Directory with the template files. These will be copied to the generated output.',
	default = 'templates')
options.add_option('-p', '--profile', dest = 'profile',
	help = 'Profile to use, either core or compatibility.', default = 'core')
options.add_option('-e', '--extensions', dest = 'extensions',
	help = 'Regular expression for the extensions to include. ' \
	'Defaults to the ARB, EXT, OES and KHR extensions.',
	default = '(GL_ARB_.*)|(GL_EXT_.*)|(GL_OES_.*)|(GL_KHR_*)')
options.add_option('-v', '--verbose', dest = 'verbose', help = 'Verbose output.', default = False,
	action = 'store_true')
(args, argv) = options.parse_args()

glXml = os.path.join(args.inDir, 'gl.xml')
glxXml = os.path.join(args.inDir, 'glx.xml')
wglXml = os.path.join(args.inDir, 'wgl.xml')

try:
	os.makedirs(args.outDir)
except OSError as e:
	if e.errno != errno.EEXIST:
		raise

for entry in os.listdir(args.templateDir):
	if not entry or entry[0] == '.':
		continue
	path = os.path.join(args.templateDir, entry)
	if os.path.isfile(path):
		shutil.copy(path, args.outDir)

diagFile = None
if args.verbose:
	diagFile = sys.stdout

write('Parsing', glXml + '...')
glRegistry = Registry()
glRegistry.loadElementTree(etree.parse(glXml))

apiname = ['gl', 'gles2']
glHeaderOptions = GeneratorOptions(
	filename = os.path.join(args.outDir, 'gl.h'),
	apiname = apiname,
	profile = args.profile,
	addExtensions = args.extensions)
write('Outputting', glHeaderOptions.filename + '...')
glRegistry.setGenerator(GLHeaderGenerator(diagFile = diagFile))
glRegistry.apiGen(glHeaderOptions)

functionPointerOptions = GeneratorOptions(
	filename = os.path.join(args.outDir, 'AnyGLFunctions.c'),
	apiname = apiname,
	profile = args.profile,
	addExtensions = args.extensions)
write('Outputting', functionPointerOptions.filename + '...')
glRegistry.apiReset()
glRegistry.setGenerator(FunctionPointerGenerator(diagFile = diagFile))
glRegistry.apiGen(functionPointerOptions)

write('Parsing', glxXml + '...')
glxRegistry = Registry()
glxRegistry.loadElementTree(etree.parse(glxXml))

glxHeaderOptions = GeneratorOptions(
	filename = os.path.join(args.outDir, 'glx.h'),
	apiname = ['glx'],
	profile = args.profile,
	addExtensions = '.*',
	removeExtensions = 'GLX_ARB_get_proc_address')
write('Outputting', glxHeaderOptions.filename + '...')
glxRegistry.setGenerator(GLXWHeaderGenerator(['X11/Xlib.h', 'X11/Xutil.h'], 'ANYGL_LOAD_GLX',
	diagFile = diagFile))
glxRegistry.apiGen(glxHeaderOptions)

write('Parsing', wglXml + '...')
wglRegistry = Registry()
wglRegistry.loadElementTree(etree.parse(wglXml))

wglHeaderOptions = GeneratorOptions(
	filename = os.path.join(args.outDir, 'wgl.h'),
	apiname = ['wgl'],
	profile = args.profile,
	emitversions = None,
	addExtensions = '.*')
write('Outputting', wglHeaderOptions.filename + '...')
wglRegistry.setGenerator(GLXWHeaderGenerator(['Windows.h'], 'ANYGL_LOAD_WGL',
	systemDefines = ['WIN32_LEAN_AND_MEAN'], diagFile = diagFile))
wglRegistry.apiGen(wglHeaderOptions)

write('Done')
