# Copyright 2017 Aaron Barany
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from .reg import *
from .FunctionInfo import *

class GLHeaderGenerator(OutputGenerator):
	def __init__(self, errFile = sys.stderr, warnFile = sys.stderr, diagFile = sys.stdout):
		OutputGenerator.__init__(self, errFile, warnFile, diagFile)
		self.lastTypeRequire = None
		self.glesOnlyTypes = ['khrplatform']
		self.glOnlyTypes = \
			[
				'stddef',
				'inttypes',
				'GLfloat',
				'GLdouble',
				'GLclampf',
				'GLclampd'
			]
		self.curFunctions = []
		self.typeLines = []
		self.enumLines = []
		self.functionLines = []

	def newLine(self):
		write('', file = self.outFile)

	def beginFile(self, genOpts):
		OutputGenerator.beginFile(self, genOpts)
		if self.genOpts.filename:
			headerSym = '__AnyGL_' + re.sub('\.h', '_h_', os.path.basename(self.genOpts.filename))
			write('#pragma once', file = self.outFile)
			write('#ifndef', headerSym, file = self.outFile)
			write('#define', headerSym, '1', file = self.outFile)
			self.newLine()

		write('#include "AnyGLConfig.h"', file = self.outFile)
		self.newLine()

		write('/* Generated by AnyGL. */', file = self.outFile)
		self.newLine()

		write('#ifdef __cplusplus', file= self.outFile)
		write('extern "C" {', file = self.outFile)
		write('#endif', file = self.outFile)
		self.newLine()

	def endFile(self):
		write('/* Type declarations */', file = self.outFile)
		for line in self.typeLines:
			write(line, file = self.outFile)
		self.newLine()

		write('/* Enum definitions */', file = self.outFile)
		for line in self.enumLines:
			write(line, file = self.outFile)
		self.newLine()

		write('/* Function declarations */', file = self.outFile)
		for line in self.functionLines:
			write(line, file = self.outFile)
		self.newLine()

		write('#ifdef __cplusplus', file = self.outFile)
		write('}', file = self.outFile)
		write('#endif', file = self.outFile)

		if self.genOpts.filename:
			self.newLine()
			write('#endif', file = self.outFile)

		OutputGenerator.endFile(self)

	def beginFeature(self, interface, emit):
		OutputGenerator.beginFeature(self, interface, emit)
		if emit:
			comment = '/* ' + interface.get('name') + ' */'
			self.typeLines.append(comment)
			self.enumLines.append(comment)
			self.functionLines.append(comment)

	def endFeature(self):
		if self.lastTypeRequire:
			self.typeLines.append('#endif /* ' + self.lastTypeRequire + ' */')
			self.lastTypeRequire = None
		self.typeLines.append('')
		self.enumLines.append('')

		if self.curFunctions:
			# Function types
			for function in self.curFunctions:
				if not function.alias:
					self.functionLines.append(function.getTypeDecl())
			self.functionLines.append('')

			# Function pointers
			for function in self.curFunctions:
				if not function.alias:
					self.functionLines.append('ANYGL_EXPORT extern ' + function.type + ' AnyGL_' \
						+ function.name + ';')
			self.functionLines.append('')

			# Function defines.
			for function in self.curFunctions:
				name = function.name
				if function.alias:
					name = function.alias
				self.functionLines.append('#define ' + function.name + ' AnyGL_' + name)
			self.functionLines.append('')

		self.curFunctions = []
		OutputGenerator.endFeature(self)

	def genType(self, typeinfo, name):
		OutputGenerator.genType(self, typeinfo, name)

		# Types are declared differently between GLES and desktop GL.
		typeElem = typeinfo.elem
		curRequire = None
		requires = typeElem.get('requires')
		if requires == 'khrplatform':
			curRequire = 'ANYGL_GLES'
		elif requires in self.glOnlyTypes:
			curRequire = '!ANYGL_GLES'
		else:
			name = typeElem.get('name')
			if name in self.glesOnlyTypes:
				curRequire = 'ANYGL_GLES'
			elif name in self.glOnlyTypes:
				curRequire = '!ANYGL_GLES'

		if curRequire != self.lastTypeRequire:
			if self.lastTypeRequire:
				self.typeLines.append('#endif /* ' + self.lastTypeRequire + ' */')

			self.typeLines.append('')
			if curRequire:
				self.typeLines.append('#if ' + curRequire)
			self.lastTypeRequire = curRequire

		s = noneStr(typeElem.text)
		for elem in typeElem:
			if (elem.tag == 'apientry'):
				s += 'APIENTRY' + noneStr(elem.tail)
			else:
				s += noneStr(elem.text) + noneStr(elem.tail)
		if (len(s) > 0):
			self.typeLines.append(s)

	def genEnum(self, enuminfo, name):
		OutputGenerator.genEnum(self, enuminfo, name)

		# Special case: GL_HALF_FLOAT_OES is a different value from GL_HALF_FLOAT
		glOnly = name == 'GL_HALF_FLOAT'
		if glOnly:
			self.enumLines.append('#if !ANYGL_GLES')

		s = '#define ' + name.ljust(33) + ' ' + enuminfo.elem.get('value')
		#
		# Handle non-integer 'type' fields by using it as the C value suffix
		t = enuminfo.elem.get('type')
		if (t != '' and t != 'i'):
			s += enuminfo.type
		self.enumLines.append(s)

		# Special case for GL_HALF_FLOAT_OES
		if name == 'GL_HALF_FLOAT_OES':
			self.enumLines.append('#if ANYGL_GLES')
			self.enumLines.append('#define GL_HALF_FLOAT GL_HALF_FLOAT_OES')
			self.enumLines.append('#endif')

		if glOnly:
			self.enumLines.append('#endif /* !ANYGL_GLES */')

	def genCmd(self, cmdinfo, name):
		OutputGenerator.genCmd(self, cmdinfo, name)
		self.curFunctions.append(FunctionInfo(cmdinfo.elem))
